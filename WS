// Replace with your values
const realm = 'us1';  // Your realm, e.g., 'us0', 'eu0'
const token = 'YOUR_ORG_ACCESS_TOKEN_HERE';  // Org token

const wsUrl = `wss://stream.\( {realm}.signalfx.com/v2/signalflow/authenticate/ \){token}`;

const ws = new WebSocket(wsUrl);

// Time window: last hour (adjust as needed)
const now = Date.now();
const oneHourAgo = now - 3600000;  // 1 hour ago in ms

// Store unique active app-DC pairs
const activeAppsByDC = new Map();  // dc -> Set of appids

ws.onopen = () => {
  console.log('WebSocket connected and authenticated!');

  // SignalFlow program: Fetch ANY metric that has both a.dc and a.appid
  // This returns all unique time series (with their dimensions) active in the window
  // No need for '*' â€” use a placeholder like 'cpu.utilization' or known metric if possible
  // To broaden: remove metric name and use extrapolation=false to avoid extras
  const program = `
    data('*', filter=filter('a.dc', '*') and filter('a.appid', '*'), extrapolation='null', maxExtrapolations=0)
    .publish();
  `;

  const executeMsg = {
    type: 'execute',
    program: program.trim(),
    start: oneHourAgo,
    stop: now,
    resolution: 60000,     // 1-minute buckets
    maxDelay: 300000,      // Up to 5 min ingestion delay
    immediate: false       // Process historical data normally
  };

  ws.send(JSON.stringify(executeMsg));
  console.log('Executing historical query for active a.dc + a.appid combinations...');
};

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);

  if (msg.type === 'metadata') {
    const properties = msg.properties || {};
    const dc = properties['a.dc'];
    const appid = properties['a.appid'];

    if (dc && appid) {
      if (!activeAppsByDC.has(dc)) {
        activeAppsByDC.set(dc, new Set());
      }
      activeAppsByDC.get(dc).add(appid);
      console.log(`Active: App/Component "\( {appid}" in Data Center " \){dc}"`);
    }
  } else if (msg.type === 'message' || msg.type === 'job-start' || msg.type === 'job-progress') {
    console.log('Status:', msg.message || msg);
  } else if (msg.type === 'end-of-channel' || msg.type === 'detach') {
    console.log('\n=== Computation Complete ===');
    console.log('Unique active applications/components by data center:');
    activeAppsByDC.forEach((apps, dc) => {
      console.log(`\nData Center: ${dc}`);
      apps.forEach(app => console.log(`  - ${app}`));
    });
    console.log('\nTotal data centers:', activeAppsByDC.size);
    let totalApps = 0;
    activeAppsByDC.forEach(apps => totalApps += apps.size);
    console.log('Total unique app/component instances:', totalApps);

    // For easy copy: JSON format
    const jsonOutput = Array.from(activeAppsByDC.entries())
      .map(([dc, apps]) => ({ data_center: dc, applications: Array.from(apps) }));
    console.log('\nJSON for recording:', JSON.stringify(jsonOutput, null, 2));
  } else if (msg.type === 'error') {
    console.error('SignalFlow Error:', msg.error || msg);
  }
};

ws.onerror = (err) => console.error('WebSocket error:', err);
ws.onclose = (event) => console.log('WebSocket closed:', event.code, event.reason);
