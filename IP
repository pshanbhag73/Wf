import * as d3 from 'd3';

function buildTracerouteVisualization(probes, containerId) {
  // Sample data structure (replace with your probes input)
  // probes = [
  //   { location: "Location1", dns: "example.com", hops: [{hopNumber: 1, hopDetails: [{ip: "10.0.0.1", time: 22.52}]}, ...] },
  //   ...
  // ];

  const width = 800;
  const height = 600;

  const svg = d3.select(`#${containerId}`)
    .append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('style', 'border: 1px solid #ccc');

  // Prepare nodes and links
  const nodes = new Map();
  const links = [];

  probes.forEach(probe => {
    const sourceId = probe.location.replace(/\s/g, '_');
    if (!nodes.has(sourceId)) {
      nodes.set(sourceId, { id: sourceId, label: probe.location, color: 'green', times: [] });
    }

    let previous = sourceId;
    probe.hops.forEach(hop => {
      hop.hopDetails.forEach(detail => {
        const current = detail.ip;
        if (!nodes.has(current)) {
          nodes.set(current, { id: current, label: current, color: 'blue', times: [] });
        }

        nodes.get(current).times.push(detail.time);
        links.push({ source: previous, target: current, count: 1 });

        previous = current;
      });

      // Handle multiple IPs per hop by branching
      if (hop.hopDetails.length > 1) {
        hop.hopDetails.slice(1).forEach(detail => {
          const current = detail.ip;
          if (!nodes.has(current)) {
            nodes.set(current, { id: current, label: current, color: 'blue', times: [] });
          }
          nodes.get(current).times.push(detail.time);
          links.push({ source: previous, target: current, count: 1 });
        });
      }
    });

    // Mark destination
    if (nodes.has(previous)) {
      const node = nodes.get(previous);
      node.label = `${node.label} (${probe.dns})`;
      node.color = 'green';
    }
  });

  // Aggregate links (count occurrences)
  const linkMap = new Map();
  links.forEach(link => {
    const key = `${link.source}->${link.target}`;
    if (linkMap.has(key)) {
      linkMap.get(key).count++;
    } else {
      linkMap.set(key, { ...link });
    }
  });
  const uniqueLinks = Array.from(linkMap.values());

  // Update node labels with average times
  nodes.forEach(node => {
    if (node.times.length > 0) {
      const avg = d3.mean(node.times);
      node.label += `\n${avg.toFixed(2)} ms`;
    }
  });

  const nodeArray = Array.from(nodes.values());
  const linkArray = uniqueLinks;

  // Simulation setup
  const simulation = d3.forceSimulation(nodeArray)
    .force('link', d3.forceLink(linkArray).id(d => d.id).distance(100))
    .force('charge', d3.forceManyBody().strength(-300))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('y', d3.forceY(0).strength(0.1)); // Hierarchical tendency

  // Draw links
  const link = svg.append('g')
    .selectAll('line')
    .data(linkArray)
    .join('line')
    .attr('stroke', '#999')
    .attr('stroke-width', d => Math.sqrt(d.count))
    .attr('marker-end', 'url(#arrowhead)');

  // Draw arrowheads
  svg.append('defs').selectAll('marker')
    .data(['arrowhead'])
    .join('marker')
    .attr('id', d => d)
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 15)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#999');

  // Draw nodes
  const node = svg.append('g')
    .selectAll('g')
    .data(nodeArray)
    .join('g')
    .call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended));

  node.append('circle')
    .attr('r', 5)
    .attr('fill', d => d.color);

  node.append('text')
    .attr('x', 8)
    .attr('y', 3)
    .text(d => d.label)
    .attr('font-size', '10px')
    .attr('text-anchor', 'start');

  // Update positions
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    node
      .attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Drag functions
  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
}

// Example usage
const probes = [
  {
    location: "22.52.156.1",
    dns: "ca000",
    hops: [
      { hopNumber: 1, hopDetails: [{ ip: "10.65.231.251", time: 10.65 }] },
      { hopNumber: 2, hopDetails: [{ ip: "162.100.14.54", time: 10.62 }, { ip: "162.100.14.55", time: 10.63 }] }
    ]
  }
];

buildTracerouteVisualization(probes, 'traceroute-container');
