import { Component, ElementRef, Input, OnChanges, OnDestroy, OnInit, SimpleChanges, ViewChild } from '@angular/core';
import * as d3 from 'd3';

interface Probe {
  location: string;
  dns: string;
  hops: Hop[];
}

interface Hop {
  hopNumber: number;
  hopDetails: HopDetail[];
}

interface HopDetail {
  ip: string;
  time: number;
}

@Component({
  selector: 'app-traceroute-visualization',
  template: `<div #tracerouteContainer style="height: 600px; width: 100%; border: 1px solid #ccc;"></div>`,
  styles: []
})
export class TracerouteVisualizationComponent implements OnInit, OnChanges, OnDestroy {
  @ViewChild('tracerouteContainer') container!: ElementRef;
  @Input() probes: Probe[] = [];

  private svg: any;
  private simulation: any;
  private zoom: any;

  ngOnInit(): void {
    this.initializeVisualization();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['probes'] && !changes['probes'].firstChange) {
      this.updateVisualization();
    }
  }

  ngOnDestroy(): void {
    if (this.simulation) {
      this.simulation.stop();
    }
    if (this.svg) {
      this.svg.remove();
    }
  }

  private initializeVisualization(): void {
    if (!this.probes || this.probes.length === 0) {
      return;
    }

    const width = 800;
    const height = 600;

    this.svg = d3.select(this.container.nativeElement)
      .append('svg')
      .attr('width', width)
      .attr('height', height);

    // Add zoom behavior
    this.zoom = d3.zoom()
      .scaleExtent([0.1, 10]) // Min and max zoom levels
      .on('zoom', (event: any) => {
        this.svg.attr('transform', event.transform);
      });
    this.svg.call(this.zoom);

    this.drawVisualization();
  }

  private updateVisualization(): void {
    if (!this.probes || this.probes.length === 0) {
      return;
    }

    // Remove existing elements
    this.svg.selectAll('*').remove();
    if (this.simulation) {
      this.simulation.stop();
    }

    this.drawVisualization();
  }

  private drawVisualization(): void {
    const width = 800;
    const height = 600;

    // Prepare nodes and links
    const nodes = new Map<string, { id: string, label: string, color: string, times: number[] }>();
    const links: { source: string, target: string, count: number }[] = [];

    this.probes.forEach(probe => {
      const sourceId = probe.location.replace(/\s/g, '_');
      if (!nodes.has(sourceId)) {
        nodes.set(sourceId, { id: sourceId, label: probe.location, color: 'green', times: [] });
      }

      let previous = sourceId;
      probe.hops.forEach(hop => {
        hop.hopDetails.forEach(detail => {
          const current = detail.ip;
          if (!nodes.has(current)) {
            nodes.set(current, { id: current, label: current, color: 'blue', times: [] });
          }

          nodes.get(current)!.times.push(detail.time);
          links.push({ source: previous, target: current, count: 1 });

          previous = current;
        });

        // Handle multiple IPs per hop by branching
        if (hop.hopDetails.length > 1) {
          hop.hopDetails.slice(1).forEach(detail => {
            const current = detail.ip;
            if (!nodes.has(current)) {
              nodes.set(current, { id: current, label: current, color: 'blue', times: [] });
            }
            nodes.get(current)!.times.push(detail.time);
            links.push({ source: previous, target: current, count: 1 });
          });
        }
      });

      // Mark destination
      if (nodes.has(previous)) {
        const node = nodes.get(previous)!;
        node.label = `${node.label} (${probe.dns})`;
        node.color = 'green';
      }
    });

    // Aggregate links (count occurrences)
    const linkMap = new Map<string, { source: string, target: string, count: number }>();
    links.forEach(link => {
      const key = `${link.source}->${link.target}`;
      if (linkMap.has(key)) {
        linkMap.get(key)!.count++;
      } else {
        linkMap.set(key, { ...link });
      }
    });
    const uniqueLinks = Array.from(linkMap.values());

    // Update node labels with average times
    nodes.forEach(node => {
      if (node.times.length > 0) {
        const avg = d3.mean(node.times) || 0;
        node.label += `\n${avg.toFixed(2)} ms`;
      }
    });

    const nodeArray = Array.from(nodes.values());
    const linkArray = uniqueLinks;

    // Simulation setup with strong horizontal layout
    this.simulation = d3.forceSimulation(nodeArray)
      .force('link', d3.forceLink(linkArray).id(d => d.id).distance(150))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('x', d3.forceX().strength(0.3)) // Stronger horizontal force
      .force('y', d3.forceY(height / 2).strength(0.05)) // Center vertically
      .force('collision', d3.forceCollide().radius(20));

    // Draw links with smooth curves
    const link = this.svg.append('g')
      .selectAll('path')
      .data(linkArray)
      .join('path')
      .attr('stroke', '#999')
      .attr('stroke-width', d => Math.sqrt(d.count) * 2) // Increased thickness for visibility
      .attr('fill', 'none')
      .attr('marker-end', 'url(#arrowhead)');

    // Draw arrowheads
    this.svg.append('defs').selectAll('marker')
      .data(['arrowhead'])
      .join('marker')
      .attr('id', d => d)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#999');

    // Draw nodes
    const node = this.svg.append('g')
      .selectAll('g')
      .data(nodeArray)
      .join('g')
      .call(d3.drag()
        .on('start', (event: any, d: any) => this.dragstarted(event, d))
        .on('drag', (event: any, d: any) => this.dragged(event, d))
        .on('end', (event: any, d: any) => this.dragended(event, d)));

    node.append('circle')
      .attr('r', 5)
      .attr('fill', d => d.color);

    node.append('text')
      .attr('x', 8)
      .attr('y', 3)
      .text(d => d.label.split('\n')[0]) // Show only IP/location initially
      .attr('font-size', '10px')
      .attr('text-anchor', 'start');

    // Add hover tooltip
    node.append('title')
      .text(d => `IP: ${d.id}\nAvg Time: ${d.times.length > 0 ? d3.mean(d.times)?.toFixed(2) : 'N/A'} ms`);

    // Update positions with smooth curves
    this.simulation.on('tick', () => {
      link.attr('d', d => {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) / 2; // Adjust curve radius
        return `M${d.source.x},${d.source.y}C${d.source.x + dx / 3},${d.source.y + dy / 3},${d.target.x - dx / 3},${d.target.y - dy / 3},${d.target.x},${d.target.y}`;
      });

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });
  }

  private dragstarted(event: any, d: any): void {
    if (!event.active) this.simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  private dragged(event: any, d: any): void {
    d.fx = event.x;
    d.fy = event.y;
  }

  private dragended(event: any, d: any): void {
    if (!event.active) this.simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
}
