import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-test-visualization',
  template: `<div *ngIf="results && results.length > 0">
    <div *ngFor="let result of results">
      <div [ngSwitch]="result.testType.toLowerCase()">
        <div *ngSwitchCase="'traceroute'">
          <div echarts [options]="chartOption" style="height: 400px; width: 100%;"></div>
        </div>
        <div *ngSwitchDefault>
          <p>No visualization available for {{ result.testType }}.</p>
        </div>
      </div>
    </div>
  </div>`,
})
export class TestVisualizationComponent implements OnInit {
  @Input() results: any[] = [];
  chartOption: any = {};

  ngOnInit() {
    this.chartOption = this.getTracerouteChartOption(this.results);
  }

  private getTracerouteChartOption(results: any[]) {
    const nodes: any[] = [];
    const links: any[] = [];
    const categories = [
      { name: 'Location', itemStyle: { color: '#007bff' } }, // Blue for locations
      { name: 'Hop', itemStyle: { color: '#ff9800' } }, // Orange for hops
      { name: 'Host', itemStyle: { color: '#4caf50' } } // Green for host
    ];

    // Map to track unique node IDs and location Y-positions
    const nodeIdMap = new Map<string, string>();
    const locationYMap = new Map<string, number>();
    let nodeIdCounter = 0;

    // Track unique locations to assign Y-positions
    const uniqueLocations = [...new Set(results.map(r => r.location || 'Default'))];
    uniqueLocations.forEach((loc, index) => {
      locationYMap.set(loc, index * 100);
    });

    results.forEach((result, index) => {
      const location = result.location || 'Default';
      const host = result.host;

      // Generate unique IDs for location and host
      const locationId = `location_${location}`;
      const hostId = `host_${index}_${host}`;

      // Add location node (only once per unique location)
      if (!nodeIdMap.has(locationId)) {
        nodes.push({
          id: locationId,
          name: location,
          category: 0,
          x: 0, // Leftmost side
          y: locationYMap.get(location), // Consistent Y for same location
          symbolSize: 30, // Smaller node size
          label: { show: true }
        });
        nodeIdMap.set(locationId, locationId);
      }

      // Add host node (rightmost position)
      if (!nodeIdMap.has(hostId)) {
        nodes.push({
          id: hostId,
          name: host,
          category: 2,
          x: 1000, // Moved to rightmost position
          y: locationYMap.get(location), // Align with location
          symbolSize: 30, // Smaller node size
          label: { show: true }
        });
        nodeIdMap.set(hostId, hostId);
      }

      // Link location to host (fallback link)
      links.push({ source: locationId, target: hostId });

      // Process hops
      if (result.parsedResult && result.parsedResult.hops) {
        let prevNodeId = locationId;
        result.parsedResult.hops.forEach((hop: any, hopIndex: number) => {
          // Create hop name (without hopNumber)
          let hopName = hop.host || hop.ip || '*';

          // Generate unique hop ID
          const hopId = `hop_${index}_${hop.hop_number}_${nodeIdCounter++}`;

          nodes.push({
            id: hopId,
            name: hopName,
            category: 1,
            x: (hopIndex + 1) * 150, // Horizontal positioning between location and host
            y: locationYMap.get(location), // Align with location
            symbolSize: 30, // Smaller node size
            label: { show: true },
            rtt1_ms: hop.rtt1_ms, // Store RTT for tooltip
            rtt2_ms: hop.rtt2_ms,
            rtt3_ms: hop.rtt3_ms
          });

          // Link to previous node
          links.push({ source: prevNodeId, target: hopId, lineStyle: { color: '#999' } });

          // Update previous node
          prevNodeId = hopId;
        });

        // Link last hop to host
        if (result.parsedResult.hops.length > 0) {
          links.push({ source: prevNodeId, target: hostId });
        }
      }
    });

    return {
      title: { text: 'Traceroute Path Visualization' },
      tooltip: {
        formatter: (params: any) => {
          if (params.data.category === 1) { // Hop
            return `Node: ${params.name}<br>RTT1: ${params.data.rtt1_ms || '*'} ms<br>RTT2: ${params.data.rtt2_ms || '*'} ms<br>RTT3: ${params.data.rtt3_ms || '*'} ms`;
          }
          return params.name;
        }
      },
      legend: [{ data: categories.map(a => a.name) }],
      series: [{
        type: 'graph',
        layout: 'none', // Fixed positions for left-to-right
        data: nodes,
        links: links,
        categories: categories,
        roam: true, // Enable zoom and drag
        label: {
          show: true,
          position: 'right',
          formatter: '{b}'
        },
        lineStyle: {
          color: 'source',
          curveness: 0.3
        }
      }]
    };
  }
}
