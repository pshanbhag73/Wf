import { Component, Input, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import * as d3 from 'd3';
import * as dagre from 'dagre';

interface Hop {
  hopNumber: number;
  rtt: number;
  host: string;
  ip?: string;
}

interface Trace {
  source: string;
  hops: Hop[];
  destination: string;
}

@Component({
  selector: 'app-traceroute-viz',
  template: `<svg #svg></svg>`,
  styles: [`svg { width: 100%; height: 800px; }`]
})
export class TracerouteVizComponent implements AfterViewInit {
  @Input() traces: Trace[] = [];

  @ViewChild('svg') svgElement!: ElementRef;

  ngAfterViewInit() {
    if (this.traces.length === 0) return;

    const svg = d3.select(this.svgElement.nativeElement);
    const boundingRect = svg.node()?.getBoundingClientRect();
    const width = boundingRect?.width || 1200;
    let height = boundingRect?.height || 800;

    // Color scale for different traces
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // Build nodes and links
    const nodeMap = new Map<string, any>();
    const nodes: any[] = [];
    const links: any[] = [];

    // Add destination node (assuming all traces share the same destination)
    const destination = this.traces[0].destination;
    const destId = `dest-${destination.replace(/\./g, '-')}`; // Sanitize for ID
    nodeMap.set(destId, { id: destId, host: destination });
    nodes.push(nodeMap.get(destId));

    this.traces.forEach((trace, index) => {
      const traceColor = color(index.toString());

      // Add source node
      const sourceId = `source-${trace.source.replace(/\./g, '-')}`;
      if (!nodeMap.has(sourceId)) {
        nodeMap.set(sourceId, { id: sourceId, host: trace.source });
        nodes.push(nodeMap.get(sourceId));
      }

      let prev = sourceId;

      trace.hops.forEach(hop => {
        const id = hop.ip ? hop.ip : `${trace.source}-hop${hop.hopNumber}-${hop.host || 'unknown'}`.replace(/\./g, '-');
        if (!nodeMap.has(id)) {
          nodeMap.set(id, { id, host: hop.host || 'unknown', ip: hop.ip });
          nodes.push(nodeMap.get(id));
        }

        links.push({ source: prev, target: id, rtt: hop.rtt, trace: trace.source, color: traceColor });
        prev = id;
      });

      // Link last hop to destination if not already
      if (prev !== destId) {
        links.push({ source: prev, target: destId, rtt: 0, trace: trace.source, color: traceColor });
      }
    });

    // Group links for multi-link curving (between same source-target pairs)
    const multiLinks = new Map<string, any[]>();
    links.forEach(link => {
      const min = link.source < link.target ? link.source : link.target;
      const max = link.source < link.target ? link.target : link.source;
      const key = `${min},${max}`;
      if (!multiLinks.has(key)) multiLinks.set(key, []);
      multiLinks.get(key)!.push(link);
    });

    // Use Dagre for layout (DAG layout, left-to-right)
    const graph = new dagre.graphlib.Graph();
    graph.setGraph({ rankdir: 'LR', nodesep: 50, ranksep: 100, marginx: 20, marginy: 20 });
    graph.setDefaultEdgeLabel(() => ({}));

    nodes.forEach(node => {
      graph.setNode(node.id, { width: 150, height: 50 });
    });

    links.forEach(link => {
      graph.setEdge(link.source, link.target);
    });

    dagre.layout(graph);

    // Assign positions to nodes
    nodes.forEach(node => {
      const gnode = graph.node(node.id);
      node.x = gnode.x;
      node.y = gnode.y;
    });

    // Adjust SVG height dynamically based on layout
    const maxY = d3.max(nodes, (n: any) => n.y) || 0;
    const minY = d3.min(nodes, (n: any) => n.y) || 0;
    height = Math.max(height, maxY - minY + 100);
    svg.attr('height', height);

    // Add arrow marker
    svg.append('defs')
      .append('marker')
      .attr('id', 'end')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#999');

    // Draw links (with curving for multiple links between same nodes)
    svg.append('g')
      .selectAll('path')
      .data(links)
      .enter()
      .append('path')
      .attr('d', d => {
        const source = graph.node(d.source);
        const target = graph.node(d.target);
        const key = d.source < d.target ? `${d.source},${d.target}` : `${d.target},${d.source}`;
        const siblings = multiLinks.get(key) || [];
        const total = siblings.length;
        if (total <= 1) {
          // Straight line
          return `M${source.x},${source.y} L${target.x},${target.y}`;
        } else {
          // Curved quadratic bezier with perpendicular offset
          const i = siblings.indexOf(d);
          const offset = 20 * (i - (total - 1) / 2);
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          let nx = -dy;
          let ny = dx;
          const len = Math.sqrt(nx * nx + ny * ny) || 1;
          nx /= len;
          ny /= len;
          const controlX = (source.x + target.x) / 2 + offset * nx;
          const controlY = (source.y + target.y) / 2 + offset * ny;
          return `M${source.x},${source.y} Q${controlX},${controlY} ${target.x},${target.y}`;
        }
      })
      .attr('stroke', d => d.color)
      .attr('stroke-width', 2)
      .attr('fill', 'none')
      .attr('marker-end', 'url(#end)');

    // Add RTT labels on links (only if rtt > 0)
    svg.append('g')
      .selectAll('text')
      .data(links.filter(l => l.rtt > 0))
      .enter()
      .append('text')
      .attr('x', d => (graph.node(d.source).x + graph.node(d.target).x) / 2)
      .attr('y', d => (graph.node(d.source).y + graph.node(d.target).y) / 2 - 5)
      .attr('font-size', 10)
      .attr('text-anchor', 'middle')
      .attr('fill', '#333')
      .text(d => `${d.rtt} ms`);

    // Draw nodes
    const nodeGroup = svg.append('g')
      .selectAll('g')
      .data(nodes)
      .enter()
      .append('g')
      .attr('transform', d => `translate(${d.x}, ${d.y})`);

    nodeGroup.append('circle')
      .attr('r', 10)
      .attr('fill', '#69b3a2');

    nodeGroup.append('text')
      .attr('x', 15)
      .attr('y', 5)
      .attr('font-size', 12)
      .text(d => `${d.host}${d.ip ? ` (${d.ip})` : ''}`);
  }
}
