import { Component, ElementRef, OnInit, OnDestroy } from '@angular/core';
import * as d3 from 'd3';
import { GlobalpingService } from '../globalping.service';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-traceroute-graph',
  template: `<div>
    <input type="text" [(ngModel)]="target" placeholder="Target (e.g., google.com)" />
    <div *ngFor="let loc of locations; let i = index">
      <input type="text" [(ngModel)]="loc.type" placeholder="Location Type (e.g., country)" />
      <input type="text" [(ngModel)]="loc.value" placeholder="Value (e.g., US)" />
      <input type="number" [(ngModel)]="loc.limit" placeholder="Probes per Location" />
    </div>
    <button (click)="addLocation()">Add Location</button>
    <button (click)="runTraceroute()">Run Traceroute</button>
    <div class="graph-container"></div>
  </div>`,
  styleUrls: ['./traceroute-graph.component.css']
})
export class TracerouteGraphComponent implements OnInit, OnDestroy {
  target: string = 'google.com';
  locations: { type: string, value: string, limit: number }[] = [{ type: 'country', value: 'US', limit: 2 }];
  private svg: any;
  private simulation: any;
  private width = 800;
  private height = 600;
  private nodes: any[] = [];
  private links: any[] = [];
  private subscription: Subscription | undefined;

  constructor(private elementRef: ElementRef, private globalpingService: GlobalpingService) {}

  ngOnInit(): void {
    this.initSvg();
  }

  addLocation() {
    this.locations.push({ type: '', value: '', limit: 1 });
  }

  runTraceroute() {
    const apiLocations = this.locations.map(loc => ({ [loc.type]: loc.value, limit: loc.limit }));
    const body = {
      type: 'traceroute',
      target: this.target,
      locations: apiLocations,
      measurementOptions: { packets: 3 }
    };
    this.globalpingService.createMeasurement(body).subscribe((res: any) => {
      const measurementId = res.id;
      this.subscription = this.globalpingService.getResults(measurementId).subscribe((results: any) => {
        this.updateGraphFromResults(results);
      });
    });
  }

  private initSvg() {
    this.svg = d3.select(this.elementRef.nativeElement.querySelector('.graph-container'))
      .append('svg')
      .attr('width', this.width)
      .attr('height', this.height)
      .style('background', '#f0f0f0');

    this.simulation = d3.forceSimulation()
      .force('link', d3.forceLink().id((d: any) => d.id).distance(150))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('y', d3.forceY((d: any, i) => {
        const locationIndex = this.nodes.findIndex(n => n.locationId === d.locationId && n.type === 'source');
        return (locationIndex * 120) % this.height;
      }).strength(0.1))
      .on('tick', this.ticked.bind(this));
  }

  private updateGraphFromResults(results: any) {
    if (results.status === 'finished') {
      this.nodes = [];
      this.links = [];
      results.forEach((result: any, locationIndex: number) => {
        const locationId = `Loc_${locationIndex}_${result.hostname}`;
        this.nodes.push({ id: locationId, label: result.hostname, type: 'source', locationId });

        let prevId = locationId;
        result.hops.forEach((hop: any, hopIndex: number) => {
          const hopId = `${locationId}_Hop_${hop.hopNumber}`;
          const uniqueIps = [...new Set(hop.hopDetails.map((detail: any) => detail.ipAddress))]; // Get unique IPs
          const avgTime = hop.hopDetails.reduce((sum: number, detail: any) => sum + detail.time, 0) / hop.hopDetails.length;

          // Parent hop node
          this.nodes.push({ id: hopId, label: `Hop ${hop.hopNumber} (Avg: ${avgTime.toFixed(1)}ms)`, type: 'hop', locationId, avgTime, details: hop.hopDetails });
          this.links.push({ source: prevId, target: hopId });

          // Sub-nodes for each unique IP
          uniqueIps.forEach((ip, ipIndex) => {
            const subNodeId = `${hopId}_IP_${ipIndex}`;
            const ipDetails = hop.hopDetails.filter((detail: any) => detail.ipAddress === ip);
            const ipAvgTime = ipDetails.reduce((sum: number, detail: any) => sum + detail.time, 0) / ipDetails.length;
            this.nodes.push({ id: subNodeId, label: `${ip} (${ipAvgTime.toFixed(1)}ms)`, type: 'subhop', locationId, parentId: hopId, details: ipDetails });
            this.links.push({ source: hopId, target: subNodeId, type: 'sub' });
          });

          prevId = hopId;
        });
      });

      this.redrawGraph();
      if (this.subscription) this.subscription.unsubscribe();
    }
  }

  private redrawGraph() {
    this.simulation.nodes(this.nodes).force('link').links(this.links);
    this.simulation.alpha(1).restart();

    this.svg.selectAll('*').remove();

    const link = this.svg.append('g')
      .selectAll('.link')
      .data(this.links)
      .enter().append('line')
      .attr('class', (d: any) => `link ${d.type === 'sub' ? 'sub-link' : ''}`)
      .attr('stroke', (d: any) => d.type === 'sub' ? '#ccc' : '#999')
      .attr('stroke-width', (d: any) => d.type === 'sub' ? 1 : 2);

    const node = this.svg.append('g')
      .selectAll('.node')
      .data(this.nodes)
      .enter().append('circle')
      .attr('class', 'node')
      .attr('r', (d: any) => d.type === 'subhop' ? 5 : Math.min(15, d.avgTime || 10))
      .attr('fill', (d: any) => d.type === 'source' ? 'green' : d.type === 'subhop' ? '#666' : 'steelblue')
      .call(this.drag(this.simulation));

    const label = this.svg.append('g')
      .selectAll('.label')
      .data(this.nodes)
      .enter().append('text')
      .attr('class', 'label')
      .text((d: any) => d.label)
      .attr('dx', 12)
      .attr('dy', '.35em')
      .style('font-size', (d: any) => d.type === 'subhop' ? '10px' : '12px');

    const tooltip = d3.select(this.elementRef.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0);

    node.on('mouseover', (event: any, d: any) => {
      tooltip.transition().duration(200).style('opacity', 0.9);
      tooltip.html(`<strong>${d.label}</strong><br>Details: ${d.details.map((det: any) => `${det.ipAddress}: ${det.time}ms`).join('<br>')}`)
        .style('left', (event.pageX + 5) + 'px')
        .style('top', (event.pageY - 28) + 'px');
    }).on('mouseout', () => {
      tooltip.transition().duration(500).style('opacity', 0);
    });

    this.ticked = () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node
        .attr('cx', (d: any) => d.x)
        .attr('cy', (d: any) => d.y);

      label
        .attr('x', (d: any) => d.x)
        .attr('y', (d: any) => d.y);
    };
  }

  private drag(simulation: any): any {
    return d3.drag()
      .on('start', (event: any, d: any) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on('drag', (event: any, d: any) => {
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', (event: any, d: any) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      });
  }

  ngOnDestroy(): void {
    if (this.simulation) this.simulation.stop();
    if (this.subscription) this.subscription.unsubscribe();
  }
}





.graph-container {
  width: 100%;
  height: 600px;
  position: relative;
}

.node {
  transition: transform 0.2s ease;
}

.node:hover {
  transform: scale(1.2);
}

.link {
  stroke: #999;
  stroke-width: 2;
}

.sub-link {
  stroke: #ccc;
  stroke-width: 1;
  stroke-dasharray: 2,2; /* Dashed for sub-links */
}

text {
  pointer-events: none;
  font-family: Arial, sans-serif;
  fill: #333;
}

text.label {
  font-size: 12px;
}

text.sub-label {
  font-size: 10px;
}

.tooltip {
  position: absolute;
  background: #fff;
  border: 1px solid #ccc;
  padding: 5px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
}




