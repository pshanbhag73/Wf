import { Component, Input, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import * as d3 from 'd3';
import * as dagre from 'dagre';

interface Hop {
  hopNumber: number;
  rtt: number;
  host: string;
  ip?: string;
  location?: string;
}

interface Trace {
  source: string;
  hops: Hop[];
  destination: string;
}

@Component({
  selector: 'app-traceroute-viz',
  template: `
    <div>
      <label>
        <input type="checkbox" [(ngModel)]="showPartial" (change)="updateViz()"> Show first & last 2 hops only
      </label>
      <svg #svg></svg>
      <div #tooltip class="tooltip" style="position: absolute; opacity: 0; background: #fff; border: 1px solid #ccc; padding: 5px; pointer-events: none; font-size: 12px;"></div>
    </div>
  `,
  styles: [`
    svg { width: 100%; height: 800px; }
    .tooltip { z-index: 10; white-space: pre; }
  `]
})
export class TracerouteVizComponent implements AfterViewInit {
  @Input() traces: Trace[] = [];
  @Input() showPartial: boolean = false;

  @ViewChild('svg') svgElement!: ElementRef;
  @ViewChild('tooltip') tooltipElement!: ElementRef;

  private svg!: d3.Selection<SVGSVGElement, unknown, null, undefined>;
  private zoomGroup!: d3.Selection<SVGGElement, unknown, null, undefined>;
  private tooltip!: d3.Selection<HTMLDivElement, unknown, null, undefined>;

  ngAfterViewInit() {
    this.svg = d3.select(this.svgElement.nativeElement);
    this.zoomGroup = this.svg.append('g');
    this.tooltip = d3.select(this.tooltipElement.nativeElement);

    this.updateViz();
  }

  private updateTooltipPosition(event: MouseEvent) {
    this.tooltip
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 10) + 'px');
  }

  updateViz() {
    this.zoomGroup.selectAll('*').remove();

    if (this.traces.length === 0) return;

    const boundingRect = this.svg.node()?.getBoundingClientRect();
    const width = boundingRect?.width || 1200;
    let height = boundingRect?.height || 800;

    // Color scale for different traces
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    // Build nodes and individual trace links for highlighting
    const processedTraces = this.showPartial ? this.traces.map(trace => ({
      ...trace,
      hops: [...trace.hops.slice(0, 2), ...trace.hops.slice(-2)]
    })) : this.traces;

    const nodeMap = new Map<string, any>();
    const nodes: any[] = [];
    const traceLinks: any[] = []; // Individual links per trace for highlighting

    // Add destination node
    const destination = this.traces[0].destination;
    const destId = `dest-${destination.replace(/\./g, '-')}`;
    nodeMap.set(destId, { id: destId, host: destination, type: 'destination', location: '' });
    nodes.push(nodeMap.get(destId));

    processedTraces.forEach((trace, index) => {
      const traceColor = color(index.toString());

      // Add source node
      const sourceId = `source-${trace.source.replace(/\./g, '-')}`;
      if (!nodeMap.has(sourceId)) {
        nodeMap.set(sourceId, { id: sourceId, host: trace.source, type: 'source', location: '' });
        nodes.push(nodeMap.get(sourceId));
      }

      let prev = sourceId;

      trace.hops.forEach(hop => {
        const id = hop.ip ? hop.ip : `${trace.source}-hop${hop.hopNumber}-${hop.host || 'unknown'}`.replace(/\./g, '-');
        if (!nodeMap.has(id)) {
          nodeMap.set(id, { id, host: hop.host || 'unknown', ip: hop.ip, hopNumber: hop.hopNumber, rtt: hop.rtt, type: 'hop', location: hop.location });
          nodes.push(nodeMap.get(id));
        }

        traceLinks.push({ source: prev, target: id, rtt: hop.rtt, trace: trace.source, color: traceColor, traceIndex: index });
        prev = id;
      });

      // Link last hop to destination
      if (prev !== destId) {
        traceLinks.push({ source: prev, target: destId, rtt: 0, trace: trace.source, color: traceColor, traceIndex: index });
      }
    });

    // Group into unique edges for drawing single paths
    const multiLinks = new Map<string, any[]>();
    traceLinks.forEach(link => {
      const min = link.source < link.target ? link.source : link.target;
      const max = link.source < link.target ? link.target : link.source;
      const key = `${min},${max}`;
      if (!multiLinks.has(key)) multiLinks.set(key, []);
      multiLinks.get(key)!.push(link);
    });

    const uniqueEdges: any[] = Array.from(multiLinks.values()).map(group => {
      const firstLink = group[0];
      const avgRtt = d3.mean(group, g => g.rtt)! || 0;
      const traces = [...new Set(group.map(g => g.trace))];
      const traceIndices = [...new Set(group.map(g => g.traceIndex))];
      return {
        source: firstLink.source,
        target: firstLink.target,
        rtt: avgRtt,
        traces,
        traceIndices,
        color: firstLink.color // Use first trace's color for the merged line
      };
    });

    // Use Dagre for layout
    const graph = new dagre.graphlib.Graph();
    graph.setGraph({ rankdir: 'LR', nodesep: 50, ranksep: 100, marginx: 20, marginy: 20 });
    graph.setDefaultEdgeLabel(() => ({}));

    nodes.forEach(node => {
      graph.setNode(node.id, { width: 200, height: 100 });
    });

    traceLinks.forEach(link => { // Use traceLinks for edges to ensure all paths are laid out
      graph.setEdge(link.source, link.target);
    });

    dagre.layout(graph);

    // Assign positions to nodes
    nodes.forEach(node => {
      const gnode = graph.node(node.id);
      node.x = gnode.x;
      node.y = gnode.y;
    });

    // Adjust SVG height
    const maxY = d3.max(nodes, (n: any) => n.y) || 0;
    const minY = d3.min(nodes, (n: any) => n.y) || 0;
    height = Math.max(height, maxY - minY + 120);
    this.svg.attr('height', height);

    // Add arrow marker
    this.zoomGroup.append('defs')
      .append('marker')
      .attr('id', 'end')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#999');

    // Draw single path per unique edge
    const linkGroup = this.zoomGroup.append('g');
    const edgePaths = linkGroup.selectAll('path')
      .data(uniqueEdges)
      .enter()
      .append('path')
      .attr('class', d => `edge-path-${d.traceIndices.join('-')}`) // Class for highlighting groups
      .attr('d', d => {
        const source = graph.node(d.source);
        const target = graph.node(d.target);
        // Straight line for merged (or slight curve if desired; here straight for "one line")
        return `M${source.x},${source.y} L${target.x},${target.y}`;
      })
      .attr('stroke', d => d.color)
      .attr('stroke-width', 2)
      .attr('fill', 'none')
      .attr('marker-end', 'url(#end)');

    // Hover on edge path: highlight all paths (edges) taken by its traces
    edgePaths.on('mouseover', (event, d) => {
      const highlightClasses = d.traceIndices.map(i => `trace-${i}`);
      traceLinks.filter(l => d.traceIndices.includes(l.traceIndex)).forEach(l => {
        linkGroup.selectAll(`.edge-path-${l.traceIndices?.join('-') || ''}`).attr('stroke-width', 4);
      });
      // Or globally: d3.selectAll('.edge-path').attr('opacity', 0.3); then reset for highlights
      d3.selectAll('.edge-path').attr('opacity', 0.3);
      d.traceIndices.forEach(i => d3.selectAll(`.edge-path-${i}`).attr('opacity', 1).attr('stroke-width', 4));
      // Tooltip with details
      const details = d.traces
        .map(t => `${t}: ${d3.mean(traceLinks.filter(l => l.trace === t && l.source === d.source && l.target === d.target), g => g.rtt) || 0} ms`)
        .join('\n');
      this.tooltip.text(details).style('opacity', 1);
      this.updateTooltipPosition(event);
    }).on('mouseout', (event) => {
      d3.selectAll('.edge-path').attr('opacity', 1).attr('stroke-width', 2);
      this.tooltip.style('opacity', 0);
    });

    // Average RTT labels
    const edgeData = uniqueEdges.filter(e => e.rtt > 0);
    const labelGroup = this.zoomGroup.append('g');
    labelGroup.selectAll('text')
      .data(edgeData)
      .enter()
      .append('text')
      .attr('x', d => {
        const source = graph.node(d.source);
        const target = graph.node(d.target);
        return (source.x + target.x) / 2;
      })
      .attr('y', d => {
        const source = graph.node(d.source);
        const target = graph.node(d.target);
        return (source.y + target.y) / 2 - 5;
      })
      .attr('font-size', 10)
      .attr('text-anchor', 'middle')
      .attr('fill', '#333')
      .text(d => `${Math.round(d.rtt)} ms (avg)`);

    // Draw nodes
    const nodeGroup = this.zoomGroup.append('g')
      .selectAll('g')
      .data(nodes)
      .enter()
      .append('g')
      .attr('transform', d => `translate(${d.x - 100}, ${d.y - 50})`);

    const circles = nodeGroup.append('circle')
      .attr('r', 10)
      .attr('cx', 100)
      .attr('cy', 40)
      .attr('fill', d => {
        if (d.type === 'source') return '#1f77b4';
        if (d.type === 'destination') return '#d62728';
        return '#69b3a2';
      })
      .on('mouseover', (event, d) => {
        const info = `Host: ${d.host}\nIP: ${d.ip || 'N/A'}\nLocation: ${d.location || 'N/A'}${d.type === 'hop' ? `\nHop: ${d.hopNumber}\nRTT: ${d.rtt} ms` : ''}`;
        this.tooltip.text(info).style('opacity', 1);
        this.updateTooltipPosition(event);
      }).on('mouseout', () => {
        this.tooltip.style('opacity', 0);
      });

    // Location label left
    nodeGroup.append('text')
      .attr('x', 20)
      .attr('y', 30)
      .attr('dy', '0.35em')
      .attr('font-size', 10)
      .attr('text-anchor', 'start')
      .attr('fill', '#666')
      .text(d => d.location || '');

    // Host/IP right
    nodeGroup.append('text')
      .attr('x', 115)
      .attr('y', 40)
      .attr('dy', '0.35em')
      .attr('font-size', 11)
      .attr('text-anchor', 'start')
      .attr('fill', '#333')
      .text(d => `${d.host}${d.ip ? ` (${d.ip})` : ''}`);

    // Hop info bottom
    nodeGroup.filter(d => d.type === 'hop')
      .append('text')
      .attr('x', 100)
      .attr('y', 70)
      .attr('dy', '0.35em')
      .attr('font-size', 9)
      .attr('text-anchor', 'middle')
      .attr('fill', '#666')
      .text(d => `Hop ${d.hopNumber} | ${d.rtt} ms`);

    // Add zoom
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.zoomGroup.attr('transform', event.transform);
      });

    this.svg.call(zoom);
  }
}
