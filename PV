package com.example.incidentpulse.service;

import com.example.incidentpulse.model.TestResult;
import com.example.incidentpulse.repository.TestResultRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Implementation of the {@link TestService} interface for executing network diagnostic tests
 * (ping, traceroute, dns) and storing results in MongoDB. Handles cross-platform command execution
 * (Windows and Linux) with timeout support and secure input processing.
 */
@Service
public class TestServiceImpl implements TestService {

    @Autowired
    private TestResultRepository repository;

    /**
     * Performs a network diagnostic test (ping, traceroute, or dns) on the specified host,
     * executes it multiple times as specified, and saves the results to MongoDB.
     *
     * @param host          The hostname or IP address to test (e.g., "google.com", "192.168.1.1").
     * @param testType      The type of test to perform ("ping", "traceroute", or "dns").
     * @param count         Number of times to execute the test (for ping, uses built-in count; for others, loops).
     * @param location      The location from which the test is run (e.g., "us-east-1"). If null, uses default.
     * @param timeoutSeconds Timeout for each test execution in seconds.
     * @return A {@link TestResult} containing the raw output, parsed results, and status ("SUCCESS", "FAILURE", or "TIMEOUT").
     * @throws IOException If an I/O error occurs during command execution.
     * @throws IllegalArgumentException If the test type is unsupported.
     */
    @Override
    public TestResult performTest(String host, String testType, int count, String location, int timeoutSeconds) throws IOException {
        String os = System.getProperty("os.name").toLowerCase();
        boolean isWindows = os.contains("win");

        StringBuilder rawOutputBuilder = new StringBuilder();
        Map<String, Object> parsedResult = new HashMap<>();
        String status = "SUCCESS";

        TestResult result = new TestResult();
        result.setHost(host);
        result.setTestType(testType);
        result.setLocation(location != null ? location : getDefaultLocation());
        result.setTimestamp(new Date());

        try {
            if (testType.equalsIgnoreCase("ping")) {
                String command = isWindows ? "ping -n " + count + " -w " + (timeoutSeconds * 1000) + " " + host 
                                        : "ping -c " + count + " -W " + timeoutSeconds + " " + host;
                executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                parsePingOutput(rawOutputBuilder.toString(), parsedResult, isWindows);
            } else if (testType.equalsIgnoreCase("traceroute")) {
                // Calculate per-hop timeout to fit within total timeoutSeconds
                int perHopTimeoutMs = Math.max(100, (timeoutSeconds * 1000) / 30); // Minimum 100ms, assuming max 30 hops
                String command = isWindows ? "tracert -w " + perHopTimeoutMs + " " + host 
                                        : "traceroute -w " + (perHopTimeoutMs / 1000.0) + " " + host;
                for (int i = 0; i < count; i++) {
                    rawOutputBuilder.append("Run " + (i + 1) + ":\n");
                    executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                    rawOutputBuilder.append("\n");
                }
                parseTracerouteOutput(rawOutputBuilder.toString(), parsedResult, isWindows);
                // Check if no hops were parsed (indicates failure)
                List<?> hops = (List<?>) parsedResult.getOrDefault("hops", new ArrayList<>());
                if (hops.isEmpty()) {
                    status = "FAILURE";
                }
            } else if (testType.equalsIgnoreCase("dns")) {
                String command = "nslookup " + host;
                for (int i = 0; i < count; i++) {
                    rawOutputBuilder.append("Run " + (i + 1) + ":\n");
                    executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                    rawOutputBuilder.append("\n");
                }
                parseDnsOutput(rawOutputBuilder.toString(), parsedResult);
                // Check if no addresses or CNAMEs were found (indicates failure)
                List<?> addresses = (List<?>) parsedResult.getOrDefault("addresses", new ArrayList<>());
                List<?> cnames = (List<?>) parsedResult.getOrDefault("cnames", new ArrayList<>());
                if (addresses.isEmpty() && cnames.isEmpty()) {
                    status = "FAILURE";
                }
            } else {
                throw new IllegalArgumentException("Unsupported test type: " + testType);
            }

            // Check for failure conditions in output
            if (rawOutputBuilder.toString().toLowerCase().contains("request timed out") ||
                rawOutputBuilder.toString().toLowerCase().contains("destination unreachable") ||
                rawOutputBuilder.toString().toLowerCase().contains("non-existent domain")) {
                status = "FAILURE";
            }
        } catch (InterruptedException e) {
            status = "TIMEOUT";
            rawOutputBuilder.append("ERROR: Test timed out after ").append(timeoutSeconds).append(" seconds\n");
        } catch (Exception e) {
            status = "FAILURE";
            rawOutputBuilder.append("ERROR: ").append(e.getMessage()).append("\n");
        }

        result.setRawOutput(rawOutputBuilder.toString());
        result.setParsedResult(parsedResult);
        result.setStatus(status);

        repository.save(result);
        return result;
    }

    /**
     * Executes a system command using ProcessBuilder, capturing stdout and stderr output.
     * Applies a timeout and handles DNS-specific output (e.g., skipping non-error stderr lines).
     *
     * @param command        The command to execute (e.g., "nslookup google.com").
     * @param isWindows      True if running on Windows, false for Linux/Unix.
     * @param outputBuilder  StringBuilder to append command output and errors.
     * @param timeoutSeconds Timeout for the command execution in seconds.
     * @param testType       Type of test ("ping", "traceroute", "dns") for specific handling.
     * @throws IOException If an I/O error occurs during command execution.
     * @throws InterruptedException If the command times out.
     */
    private void executeCommand(String command, boolean isWindows, StringBuilder outputBuilder, int timeoutSeconds, String testType) 
            throws IOException, InterruptedException {
        ProcessBuilder pb = new ProcessBuilder();
        if (isWindows) {
            pb.command("cmd.exe", "/c", command);
        } else {
            pb.command("sh", "-c", command);
        }
        Process process = pb.start();
        
        // Read output (stdout)
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            outputBuilder.append(line).append("\n");
        }
        
        // Read errors (stderr) with special handling for DNS
        BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
        boolean hasError = false;
        while ((line = errorReader.readLine()) != null) {
            // For DNS, skip non-error stderr lines like "Non-authoritative answer:"
            if (testType.equalsIgnoreCase("dns") && line.contains("Non-authoritative answer:")) {
                outputBuilder.append(line).append("\n");
                continue;
            }
            outputBuilder.append("ERROR: ").append(line).append("\n");
            hasError = true;
        }
        
        // Wait for process with timeout
        boolean exited = process.waitFor(timeoutSeconds, TimeUnit.SECONDS);
        if (!exited) {
            process.destroyForcibly(); // Forcefully terminate process on timeout
            throw new InterruptedException("Process timed out");
        }

        // Append exit code error only if no stderr errors were captured and exit code is non-zero
        int exitCode = process.exitValue();
        if (exitCode != 0 && !hasError && !testType.equalsIgnoreCase("dns")) {
            outputBuilder.append("ERROR: Process exited with code ").append(exitCode).append("\n");
        }
    }

    /**
     * Parses ping command output to extract packet loss and round-trip time metrics.
     *
     * @param output     The raw command output from the ping command.
     * @param parsed     Map to store parsed results (e.g., packet_loss_percent, min_rtt_ms).
     * @param isWindows  True if running on Windows, false for Linux/Unix.
     */
    private void parsePingOutput(String output, Map<String, Object> parsed, boolean isWindows) {
        if (isWindows) {
            Pattern lossPattern = Pattern.compile("Lost = (\\d+) \\((\\d+)% loss\\)");
            Pattern rttPattern = Pattern.compile("Minimum = (\\d+)ms, Maximum = (\\d+)ms, Average = (\\d+)ms");
            Matcher lossMatcher = lossPattern.matcher(output);
            if (lossMatcher.find()) {
                parsed.put("packet_loss_percent", Integer.parseInt(lossMatcher.group(2)));
            }
            Matcher rttMatcher = rttPattern.matcher(output);
            if (rttMatcher.find()) {
                parsed.put("min_rtt_ms", Integer.parseInt(rttMatcher.group(1)));
                parsed.put("max_rtt_ms", Integer.parseInt(rttMatcher.group(2)));
                parsed.put("avg_rtt_ms", Integer.parseInt(rttMatcher.group(3)));
            }
        } else {
            Pattern lossPattern = Pattern.compile("(\\d+) packets transmitted, (\\d+) received, (\\d+)% packet loss");
            Pattern rttPattern = Pattern.compile("rtt min/avg/max/mdev = (\\d+\\.\\d+)/(\\d+\\.\\d+)/(\\d+\\.\\d+)/(\\d+\\.\\d+) ms");
            Matcher lossMatcher = lossPattern.matcher(output);
            if (lossMatcher.find()) {
                parsed.put("packet_loss_percent", Integer.parseInt(lossMatcher.group(3)));
            }
            Matcher rttMatcher = rttPattern.matcher(output);
            if (rttMatcher.find()) {
                parsed.put("min_rtt_ms", Double.parseDouble(rttMatcher.group(1)));
                parsed.put("avg_rtt_ms", Double.parseDouble(rttMatcher.group(2)));
                parsed.put("max_rtt_ms", Double.parseDouble(rttMatcher.group(3)));
                parsed.put("mdev_rtt_ms", Double.parseDouble(rttMatcher.group(4)));
            }
        }
    }

    /**
     * Parses traceroute command output to extract hop details (e.g., hop number, host, RTTs).
     *
     * @param output     The raw command output from the traceroute command.
     * @param parsed     Map to store parsed results (e.g., list of hops with details).
     * @param isWindows  True if running on Windows, false for Linux/Unix.
     */
    private void parseTracerouteOutput(String output, Map<String, Object> parsed, boolean isWindows) {
        List<Map<String, Object>> hops = new ArrayList<>();
        String[] lines = output.split("\n");
        Pattern hopPattern = isWindows ? Pattern.compile("^(\\d+)\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+)") :
                Pattern.compile("^(\\d+)\\s+(\\S+)\\s+\\((\\S+)\\)\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+) ms");
        for (String line : lines) {
            Matcher matcher = hopPattern.matcher(line.trim());
            if (matcher.find()) {
                Map<String, Object> hop = new HashMap<>();
                hop.put("hop_number", Integer.parseInt(matcher.group(1)));
                if (isWindows) {
                    hop.put("rtt1_ms", matcher.group(2));
                    hop.put("rtt2_ms", matcher.group(3));
                    hop.put("rtt3_ms", matcher.group(4));
                    hop.put("host", matcher.group(5));
                } else {
                    hop.put("host", matcher.group(2));
                    hop.put("ip", matcher.group(3));
                    hop.put("rtt1_ms", matcher.group(4));
                    hop.put("rtt2_ms", matcher.group(5));
                    hop.put("rtt3_ms", matcher.group(6));
                }
                hops.add(hop);
            }
        }
        parsed.put("hops", hops);
    }

    /**
     * Parses nslookup command output to extract IP addresses and CNAME records.
     * Handles spaces in "Address:" and "Name:" lines and processes each run independently.
     *
     * @param output The raw command output from the nslookup command.
     * @param parsed Map to store parsed results (e.g., addresses, cnames).
     */
    private void parseDnsOutput(String output, Map<String, Object> parsed) {
        List<String> addresses = new ArrayList<>();
        List<String> cnames = new ArrayList<>();
        
        // Patterns to handle spaces
        Pattern addressPattern = Pattern.compile("Address:\\s*(\\S+)");
        Pattern cnamePattern = Pattern.compile("Name:\\s+(\\S+)");
        
        String[] lines = output.split("\n");
        String currentName = null;
        for (String line : lines) {
            // Reset currentName at the start of each run
            if (line.startsWith("Run ")) {
                currentName = null;
            }
            
            Matcher cnameMatcher = cnamePattern.matcher(line);
            if (cnameMatcher.find()) {
                currentName = cnameMatcher.group(1);
                if (!cnames.contains(currentName)) {
                    cnames.add(currentName);
                }
            }
            
            Matcher addressMatcher = addressPattern.matcher(line);
            if (addressMatcher.find()) {
                String address = addressMatcher.group(1);
                if (!addresses.contains(address)) {
                    addresses.add(address);
                }
            }
        }
        
        parsed.put("addresses", addresses);
        parsed.put("cnames", cnames); // Always include, even if empty
    }

    /**
     * Retrieves the default location (hostname) of the local machine.
     *
     * @return The hostname of the local machine, or "unknown" if an error occurs.
     */
    private String getDefaultLocation() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown";
        }
    }
}
