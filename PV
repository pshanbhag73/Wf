package com.example.incidentpulse.service;

import com.example.incidentpulse.model.TestResult;
import com.example.incidentpulse.repository.TestResultRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class TestServiceImpl implements TestService {

    @Autowired
    private TestResultRepository repository;

    @Override
    public TestResult performTest(String host, String testType, int count, String location, int timeoutSeconds) throws IOException {
        String os = System.getProperty("os.name").toLowerCase();
        boolean isWindows = os.contains("win");

        StringBuilder rawOutputBuilder = new StringBuilder();
        Map<String, Object> parsedResult = new HashMap<>();
        String status = "SUCCESS";

        TestResult result = new TestResult();
        result.setHost(host);
        result.setTestType(testType);
        result.setLocation(location != null ? location : getDefaultLocation());
        result.setTimestamp(new Date());

        try {
            if (testType.equalsIgnoreCase("ping")) {
                String command = isWindows ? "ping -n " + count + " -w " + (timeoutSeconds * 1000) + " " + host 
                                        : "ping -c " + count + " -W " + timeoutSeconds + " " + host;
                executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                parsePingOutput(rawOutputBuilder.toString(), parsedResult, isWindows);
            } else if (testType.equalsIgnoreCase("traceroute")) {
                String command = isWindows ? "tracert -w " + (timeoutSeconds * 1000) + " " + host 
                                        : "traceroute -w " + timeoutSeconds + " " + host;
                for (int i = 0; i < count; i++) {
                    rawOutputBuilder.append("Run " + (i + 1) + ":\n");
                    executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                    rawOutputBuilder.append("\n");
                }
                parseTracerouteOutput(rawOutputBuilder.toString(), parsedResult, isWindows);
            } else if (testType.equalsIgnoreCase("dns")) {
                String command = "nslookup " + host;
                for (int i = 0; i < count; i++) {
                    rawOutputBuilder.append("Run " + (i + 1) + ":\n");
                    executeCommand(command, isWindows, rawOutputBuilder, timeoutSeconds, testType);
                    rawOutputBuilder.append("\n");
                }
                parseDnsOutput(rawOutputBuilder.toString(), parsedResult);
                // Check if no addresses or CNAMEs were found (indicates failure)
                List<?> addresses = (List<?>) parsedResult.getOrDefault("addresses", new ArrayList<>());
                List<?> cnames = (List<?>) parsedResult.getOrDefault("cnames", new ArrayList<>());
                if (addresses.isEmpty() && cnames.isEmpty()) {
                    status = "FAILURE";
                }
            } else {
                throw new IllegalArgumentException("Unsupported test type: " + testType);
            }

            // Check for failure conditions in output (excluding non-authoritative answer)
            if (rawOutputBuilder.toString().toLowerCase().contains("request timed out") ||
                rawOutputBuilder.toString().toLowerCase().contains("destination unreachable") ||
                rawOutputBuilder.toString().toLowerCase().contains("non-existent domain")) {
                status = "FAILURE";
            }
        } catch (InterruptedException e) {
            status = "TIMEOUT";
            rawOutputBuilder.append("ERROR: Test timed out after ").append(timeoutSeconds).append(" seconds\n");
        } catch (Exception e) {
            status = "FAILURE";
            rawOutputBuilder.append("ERROR: ").append(e.getMessage()).append("\n");
        }

        result.setRawOutput(rawOutputBuilder.toString());
        result.setParsedResult(parsedResult);
        result.setStatus(status);

        repository.save(result);
        return result;
    }

    private void executeCommand(String command, boolean isWindows, StringBuilder outputBuilder, int timeoutSeconds, String testType) 
            throws IOException, InterruptedException {
        ProcessBuilder pb = new ProcessBuilder();
        if (isWindows) {
            pb.command("cmd.exe", "/c", command);
        } else {
            pb.command("sh", "-c", command);
        }
        Process process = pb.start();
        
        // Read output (stdout)
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            outputBuilder.append(line).append("\n");
        }
        
        // Read errors (stderr) with special handling for DNS
        BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
        boolean hasError = false;
        while ((line = errorReader.readLine()) != null) {
            // For DNS, skip non-error stderr lines like "Non-authoritative answer:"
            if (testType.equalsIgnoreCase("dns") && line.contains("Non-authoritative answer:")) {
                outputBuilder.append(line).append("\n"); // Add to output without ERROR: prefix
                continue;
            }
            outputBuilder.append("ERROR: ").append(line).append("\n");
            hasError = true;
        }
        
        // Wait for process with timeout
        boolean exited = process.waitFor(timeoutSeconds, TimeUnit.SECONDS);
        if (!exited) {
            process.destroy();
            throw new InterruptedException("Process timed out");
        }

        // Append exit code error only if no stderr errors were captured and exit code is non-zero
        int exitCode = process.exitValue();
        if (exitCode != 0 && !hasError && !testType.equalsIgnoreCase("dns")) {
            outputBuilder.append("ERROR: Process exited with code ").append(exitCode).append("\n");
        }
    }

    private void parsePingOutput(String output, Map<String, Object> parsed, boolean isWindows) {
        if (isWindows) {
            Pattern lossPattern = Pattern.compile("Lost = (\\d+) \\((\\d+)% loss\\)");
            Pattern rttPattern = Pattern.compile("Minimum = (\\d+)ms, Maximum = (\\d+)ms, Average = (\\d+)ms");
            Matcher lossMatcher = lossPattern.matcher(output);
            if (lossMatcher.find()) {
                parsed.put("packet_loss_percent", Integer.parseInt(lossMatcher.group(2)));
            }
            Matcher rttMatcher = rttPattern.matcher(output);
            if (rttMatcher.find()) {
                parsed.put("min_rtt_ms", Integer.parseInt(rttMatcher.group(1)));
                parsed.put("max_rtt_ms", Integer.parseInt(rttMatcher.group(2)));
                parsed.put("avg_rtt_ms", Integer.parseInt(rttMatcher.group(3)));
            }
        } else {
            Pattern lossPattern = Pattern.compile("(\\d+) packets transmitted, (\\d+) received, (\\d+)% packet loss");
            Pattern rttPattern = Pattern.compile("rtt min/avg/max/mdev = (\\d+\\.\\d+)/(\\d+\\.\\d+)/(\\d+\\.\\d+)/(\\d+\\.\\d+) ms");
            Matcher lossMatcher = lossPattern.matcher(output);
            if (lossMatcher.find()) {
                parsed.put("packet_loss_percent", Integer.parseInt(lossMatcher.group(3)));
            }
            Matcher rttMatcher = rttPattern.matcher(output);
            if (rttMatcher.find()) {
                parsed.put("min_rtt_ms", Double.parseDouble(rttMatcher.group(1)));
                parsed.put("avg_rtt_ms", Double.parseDouble(rttMatcher.group(2)));
                parsed.put("max_rtt_ms", Double.parseDouble(rttMatcher.group(3)));
                parsed.put("mdev_rtt_ms", Double.parseDouble(rttMatcher.group(4)));
            }
        }
    }

    private void parseTracerouteOutput(String output, Map<String, Object> parsed, boolean isWindows) {
        List<Map<String, Object>> hops = new ArrayList<>();
        String[] lines = output.split("\n");
        Pattern hopPattern = isWindows ? Pattern.compile("^(\\d+)\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+)") :
                Pattern.compile("^(\\d+)\\s+(\\S+)\\s+\\((\\S+)\\)\\s+(\\S+) ms\\s+(\\S+) ms\\s+(\\S+) ms");
        for (String line : lines) {
            Matcher matcher = hopPattern.matcher(line.trim());
            if (matcher.find()) {
                Map<String, Object> hop = new HashMap<>();
                hop.put("hop_number", Integer.parseInt(matcher.group(1)));
                if (isWindows) {
                    hop.put("rtt1_ms", matcher.group(2));
                    hop.put("rtt2_ms", matcher.group(3));
                    hop.put("rtt3_ms", matcher.group(4));
                    hop.put("host", matcher.group(5));
                } else {
                    hop.put("host", matcher.group(2));
                    hop.put("ip", matcher.group(3));
                    hop.put("rtt1_ms", matcher.group(4));
                    hop.put("rtt2_ms", matcher.group(5));
                    hop.put("rtt3_ms", matcher.group(6));
                }
                hops.add(hop);
            }
        }
        parsed.put("hops", hops);
    }

    private void parseDnsOutput(String output, Map<String, Object> parsed) {
        List<String> addresses = new ArrayList<>();
        List<String> cnames = new ArrayList<>();
        
        // Updated patterns to handle spaces
        Pattern addressPattern = Pattern.compile("Address:\\s*(\\S+)");
        Pattern cnamePattern = Pattern.compile("Name:\\s+(\\S+)");
        
        String[] lines = output.split("\n");
        String currentName = null;
        for (String line : lines) {
            // Reset currentName at the start of each run
            if (line.startsWith("Run ")) {
                currentName = null;
            }
            
            Matcher cnameMatcher = cnamePattern.matcher(line);
            if (cnameMatcher.find()) {
                currentName = cnameMatcher.group(1);
                if (!cnames.contains(currentName)) {
                    cnames.add(currentName);
                }
            }
            
            Matcher addressMatcher = addressPattern.matcher(line);
            if (addressMatcher.find() && currentName != null) {
                String address = addressMatcher.group(1);
                if (!addresses.contains(address)) {
                    addresses.add(address);
                }
            }
        }
        
        parsed.put("addresses", addresses);
        parsed.put("cnames", cnames); // Always include, even if empty
    }

    private String getDefaultLocation() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown";
        }
    }
}
