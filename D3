export const treeData = {
  name: "RootApp",
  type: "app",
  children: [
    {
      name: "App1",
      type: "app",
      children: [
        {
          name: "ServiceA",
          type: "service",
          children: [{ name: "DependencyX", type: "dependency" }]
        },
        { name: "ServiceB", type: "service" }
      ]
    },
    {
      name: "App2",
      type: "app",
      children: [
        {
          name: "ServiceA", // Same name as in App1
          type: "service",
          children: [{ name: "DependencyY", type: "dependency" }]
        },
        { name: "ServiceC", type: "service" }
      ]
    },
    { name: "RootService1", type: "service" },
    { name: "RootService2", type: "service" },
    { name: "RootDependency1", type: "dependency" },
    { name: "RootDependency2", type: "dependency" }
  ]
};

// Communication links including apps and disambiguated services
export const communicationLinks = [
  { source: "RootService1", target: "App1/ServiceA" }, // RootService1 to App1's ServiceA
  { source: "RootService2", target: "ServiceC" },       // RootService2 to App2's ServiceC
  { source: "App1", target: "App2" },                  // App1 communicates with App2
  { source: "App2/ServiceA", target: "App1/ServiceA" } // ServiceA in App2 to ServiceA in App1
];


import { Component, OnInit } from '@angular/core';
import * as d3 from 'd3';
import { treeData, communicationLinks } from '../data/tree-data';

@Component({
  selector: 'app-tree-visualization',
  template: `
    <div>
      <button (click)="levelUp()" [disabled]="!currentNode.parent">Level Up</button>
      <button (click)="levelDown()" [disabled]="!currentNode.children || currentNode.children.length === 0">Level Down</button>
      <div id="tree-container"></div>
    </div>
  `,
  styles: [`#tree-container { width: 100%; height: 600px; }`]
})
export class TreeVisualizationComponent implements OnInit {
  private svg: any;
  private g: any;
  private currentNode: any;
  private zoom: any;

  ngOnInit() {
    this.currentNode = d3.hierarchy(treeData);
    this.createTree();
  }

  createTree() {
    const width = 800;
    const height = 600;

    d3.select('#tree-container').select('svg').remove();

    this.svg = d3.select('#tree-container')
      .append('svg')
      .attr('width', width)
      .attr('height', height);

    this.zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.g.attr('transform', event.transform);
      });
    this.svg.call(this.zoom);

    this.g = this.svg.append('g')
      .attr('transform', 'translate(50,50)');

    const treeLayout = d3.tree().size([height - 100, width - 100]);
    treeLayout(this.currentNode);

    this.g.selectAll('.link')
      .data(this.currentNode.links())
      .enter()
      .append('path')
      .attr('class', 'link')
      .attr('d', d3.linkHorizontal()
        .x(d => d.y)
        .y(d => d.x))
      .attr('fill', 'none')
      .attr('stroke', '#ccc');

    const node = this.g.selectAll('.node')
      .data(this.currentNode.descendants())
      .enter()
      .append('g')
      .attr('class', 'node')
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .on('click', (event, d) => this.handleNodeClick(event, d))
      .on('dblclick', (event, d) => this.handleNodeDoubleClick(event, d));

    node.append('circle')
      .attr('r', 5)
      .attr('fill', d => {
        if (d.data.type === 'app') return '#1f77b4';
        if (d.data.type === 'service') return '#ff7f0e';
        return '#2ca02c';
      });

    node.append('text')
      .attr('dy', 3)
      .attr('x', d => d.children ? -10 : 10)
      .attr('text-anchor', d => d.children ? 'end' : 'start')
      .text(d => d.data.name);

    this.drawCommunicationLinks();
  }

  private drawCommunicationLinks() {
    // Build a map of nodes with full paths for disambiguation
    const nodes = this.currentNode.descendants();
    const nodeMap = new Map<string, { x: number; y: number }>();
    nodes.forEach(d => {
      const path = this.getNodePath(d);
      nodeMap.set(path, { x: d.x, y: d.y });
    });

    this.g.selectAll('.comm-link')
      .data(communicationLinks)
      .enter()
      .append('path')
      .attr('class', 'comm-link')
      .attr('d', d => {
        const source = nodeMap.get(d.source);
        const target = nodeMap.get(d.target);
        if (source && target) {
          return d3.linkHorizontal()({
            source: [source.y, source.x],
            target: [target.y, target.x]
          });
        }
        return null;
      })
      .attr('fill', 'none')
      .attr('stroke', '#999')
      .attr('stroke-dasharray', '5,5');
  }

  // Helper to construct full path for a node (e.g., "App1/ServiceA")
  private getNodePath(node: any): string {
    const pathParts = [];
    let current = node;
    while (current) {
      pathParts.unshift(current.data.name);
      current = current.parent;
    }
    return pathParts.join('/');
  }

  private handleNodeClick(event: any, d: any) {
    event.stopPropagation();
    if (d.data.type === 'app') {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else if (d._children) {
        d.children = d._children;
        d._children = null;
      }
      this.createTree();
    } else if (d.data.type === 'dependency') {
      alert(`Clicked dependency: ${d.data.name}`);
    }
  }

  private handleNodeDoubleClick(event: any, d: any) {
    event.stopPropagation();
    if (d.data.type === 'app') {
      const scale = 1;
      const x = -d.y * scale + this.svg.attr('width') / 2;
      const y = -d.x * scale + this.svg.attr('height') / 2;
      const transform = d3.zoomIdentity.translate(x, y).scale(scale);
      this.svg.transition().duration(750).call(this.zoom.transform, transform);
    }
  }

  levelUp() {
    if (this.currentNode.parent) {
      this.currentNode = this.currentNode.parent;
      this.createTree();
    }
  }

  levelDown() {
    if (this.currentNode.children && this.currentNode.children.length > 0) {
      this.currentNode = this.currentNode.children[0];
      this.createTree();
    }
  }
}
