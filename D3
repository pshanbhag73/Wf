export interface ServiceNode {
  id: string;
  name: string;
  type: string; // e.g., 'app', 'database', 'queue'
}

export interface ServiceLink {
  source: string;
  target: string;
  type: string; // e.g., 'sync', 'async'
}

export const serviceData = {
  nodes: [
    { id: 'app1', name: 'UserService', type: 'app' },
    { id: 'app2', name: 'OrderService', type: 'app' },
    { id: 'db1', name: 'UserDB', type: 'database' },
    { id: 'queue1', name: 'OrderQueue', type: 'queue' },
    { id: 'app3', name: 'PaymentService', type: 'app' },
  ],
  links: [
    { source: 'app1', target: 'db1', type: 'sync' },
    { source: 'app2', target: 'queue1', type: 'async' },
    { source: 'queue1', target: 'app3', type: 'sync' },
    { source: 'app3', target: 'app2', type: 'sync' },
  ],
};


import { Component, AfterViewInit, ElementRef, ViewChild } from '@angular/core';
import * as d3 from 'd3';
import { serviceData, ServiceNode, ServiceLink } from '../service-data';

@Component({
  selector: 'app-service-flowmap',
  template: '<div #flowmapContainer></div>',
  styles: [
    `
      :host {
        display: block;
        width: 100%;
        height: 100vh;
      }
      div {
        width: 100%;
        height: 100%;
      }
    `,
  ],
})
export class ServiceFlowmapComponent implements AfterViewInit {
  @ViewChild('flowmapContainer') flowmapContainer!: ElementRef;

  private width = 800;
  private height = 600;

  ngAfterViewInit() {
    this.createFlowmap();
  }

  private createFlowmap() {
    const svg = d3
      .select(this.flowmapContainer.nativeElement)
      .append('svg')
      .attr('width', this.width)
      .attr('height', this.height);

    // Create a simulation for force-directed layout
    const simulation = d3
      .forceSimulation<ServiceNode>(serviceData.nodes)
      .force(
        'link',
        d3
          .forceLink<ServiceNode, ServiceLink>(serviceData.links)
          .id((d) => d.id)
          .distance(150)
      )
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(this.width / 2, this.height / 2));

    // Draw links (dependencies)
    const link = svg
      .append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(serviceData.links)
      .enter()
      .append('line')
      .attr('stroke', (d) => (d.type === 'sync' ? '#999' : '#f66')) // Solid for sync, dashed for async
      .attr('stroke-dasharray', (d) => (d.type === 'async' ? '5,5' : '0'))
      .attr('stroke-width', 2);

    // Draw nodes (services)
    const node = svg
      .append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(serviceData.nodes)
      .enter()
      .append('g')
      .call(
        d3
          .drag<SVGGElement, ServiceNode>()
          .on('start', dragStarted)
          .on('drag', dragged)
          .on('end', dragEnded)
      );

    // Add circles for nodes
    node
      .append('circle')
      .attr('r', 20)
      .attr('fill', (d) => {
        switch (d.type) {
          case 'app':
            return '#1f77b4';
          case 'database':
            return '#ff7f0e';
          case 'queue':
            return '#2ca02c';
          default:
            return '#d62728';
        }
      });

    // Add labels to nodes
    node
      .append('text')
      .attr('dy', 4)
      .attr('text-anchor', 'middle')
      .attr('fill', '#fff')
      .text((d) => d.name);

    // Update positions on each tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d) => (d.source as any).x)
        .attr('y1', (d) => (d.source as any).y)
        .attr('x2', (d) => (d.target as any).x)
        .attr('y2', (d) => (d.target as any).y);

      node.attr('transform', (d) => `translate(${d.x},${d.y})`);
    });

    // Drag functions
    function dragStarted(event: any, d: any) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event: any, d: any) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragEnded(event: any, d: any) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
  }
}
