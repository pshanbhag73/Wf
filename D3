export interface MicroserviceNode {
  id: string;
  name: string;
  type: string; // e.g., 'service', 'database', 'queue', 'external'
  app: string; // New property to group services by app
}

export interface MicroserviceLink {
  source: string;
  target: string;
  interaction: string; // e.g., 'http', 'queue', 'db'
}

export const microservicesData = {
  nodes: [
    { id: 'ms1', name: 'AuthService', type: 'service', app: 'AuthApp' },
    { id: 'db1', name: 'AuthDB', type: 'database', app: 'AuthApp' },
    { id: 'ms2', name: 'ProductService', type: 'service', app: 'ProductApp' },
    { id: 'db2', name: 'ProductDB', type: 'database', app: 'ProductApp' },
    { id: 'ms3', name: 'OrderService', type: 'service', app: 'OrderApp' },
    { id: 'queue1', name: 'OrderQueue', type: 'queue', app: 'OrderApp' },
    { id: 'ext1', name: 'PaymentGateway', type: 'external', app: 'OrderApp' },
  ],
  links: [
    { source: 'ms1', target: 'db1', interaction: 'db' },
    { source: 'ms2', target: 'db2', interaction: 'db' },
    { source: 'ms3', target: 'queue1', interaction: 'queue' },
    { source: 'ms3', target: 'ms2', interaction: 'http' },
    { source: 'ms3', target: 'ext1', interaction: 'http' },
  ],
};


import { Component, AfterViewInit, ElementRef, ViewChild } from '@angular/core';
import * as d3 from 'd3';
import { microservicesData, MicroserviceNode, MicroserviceLink } from '../microservices-data';

@Component({
  selector: 'app-microservices-flowmap',
  template: '<div #flowmapContainer></div>',
  styles: [
    `
      :host {
        display: block;
        width: 100%;
        height: 100vh;
      }
      div {
        width: 100%;
        height: 100%;
      }
    `,
  ],
})
export class MicroservicesFlowmapComponent implements AfterViewInit {
  @ViewChild('flowmapContainer') flowmapContainer!: ElementRef;

  private width = 800;
  private height = 600;
  private svg: any;

  ngAfterViewInit() {
    this.initializeSvg();
    this.renderFlowmap();
  }

  private initializeSvg() {
    this.svg = d3
      .select(this.flowmapContainer.nativeElement)
      .append('svg')
      .attr('width', this.width)
      .attr('height', this.height);
  }

  private renderFlowmap() {
    const nodes = microservicesData.nodes;
    const links = microservicesData.links;

    // Force simulation with clustering by app
    const simulation = d3
      .forceSimulation<MicroserviceNode>(nodes)
      .force(
        'link',
        d3
          .forceLink<MicroserviceNode, MicroserviceLink>(links)
          .id((d) => d.id)
          .distance(100)
      )
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(this.width / 2 - 100, this.height / 2))
      .force('collision', d3.forceCollide(20)); // Prevent overlap with smaller dots

    // Draw links
    const link = this.svg
      .append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .enter()
      .append('line')
      .attr('stroke', (d) => this.getLinkColor(d.interaction))
      .attr('stroke-width', 2);

    // Draw link labels
    const linkLabels = this.svg
      .append('g')
      .attr('class', 'link-labels')
      .selectAll('text')
      .data(links)
      .enter()
      .append('text')
      .attr('dy', -5)
      .attr('text-anchor', 'middle')
      .attr('fill', '#333')
      .text((d) => d.interaction);

    // Draw nodes
    const node = this.svg
      .append('g')
      .attr('class', 'nodes')
      .selectAll('g')
      .data(nodes)
      .enter()
      .append('g');

    // Add smaller circles for nodes
    node
      .append('circle')
      .attr('r', 5) // Even smaller radius
      .attr('fill', (d) => this.getNodeColor(d.type));

    // Add node labels below the circles
    node
      .append('text')
      .attr('dy', 15) // Adjusted for smaller radius (5 + offset)
      .attr('text-anchor', 'middle')
      .attr('fill', '#000')
      .text((d) => d.name);

    // Add app labels (positioned slightly below the node name)
    node
      .append('text')
      .attr('dy', 30) // Below the node name
      .attr('text-anchor', 'middle')
      .attr('fill', '#666') // Lighter gray for app names
      .attr('font-size', '12px')
      .text((d) => d.app);

    // Update positions on each tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d) => (d.source as any).x)
        .attr('y1', (d) => (d.source as any).y)
        .attr('x2', (d) => (d.target as any).x)
        .attr('y2', (d) => (d.target as any).y);

      linkLabels
        .attr('x', (d) => ((d.source as any).x + (d.target as any).x) / 2)
        .attr('y', (d) => ((d.source as any).y + (d.target as any).y) / 2);

      node.attr('transform', (d) => `translate(${d.x},${d.y})`);
    });

    // Add legend
    this.addLegend();
  }

  private getNodeColor(type: string): string {
    switch (type) {
      case 'service':
        return '#1f77b4';
      case 'database':
        return '#ff7f0e';
      case 'queue':
        return '#2ca02c';
      case 'external':
        return '#d62728';
      default:
        return '#999';
    }
  }

  private getLinkColor(interaction: string): string {
    switch (interaction) {
      case 'http':
        return '#1f77b4';
      case 'queue':
        return '#2ca02c';
      case 'db':
        return '#ff7f0e';
      default:
        return '#999';
    }
  }

  private addLegend() {
    const legend = this.svg.append('g')
      .attr('class', 'legend')
      .attr('transform', `translate(${this.width - 150}, 20)`);

    const nodeLegendData = [
      { label: 'Service', color: '#1f77b4' },
      { label: 'Database', color: '#ff7f0e' },
      { label: 'Queue', color: '#2ca02c' },
      { label: 'External', color: '#d62728' },
    ];

    const linkLegendData = [
      { label: 'HTTP', color: '#1f77b4' },
      { label: 'Queue', color: '#2ca02c' },
      { label: 'DB', color: '#ff7f0e' },
    ];

    // Draw node legend
    const nodeLegend = legend.selectAll('.node-legend')
      .data(nodeLegendData)
      .enter()
      .append('g')
      .attr('class', 'node-legend')
      .attr('transform', (d, i) => `translate(0, ${i * 25})`);

    nodeLegend
      .append('circle')
      .attr('r', 5)
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('fill', (d) => d.color);

    nodeLegend
      .append('text')
      .attr('x', 15)
      .attr('y', 5)
      .attr('fill', '#000')
      .text((d) => d.label);

    // Draw link legend
    const linkLegend = legend.selectAll('.link-legend')
      .data(linkLegendData)
      .enter()
      .append('g')
      .attr('class', 'link-legend')
      .attr('transform', (d, i) => `translate(0, ${(i + nodeLegendData.length + 1) * 25})`);

    linkLegend
      .append('line')
      .attr('x1', -5)
      .attr('y1', 0)
      .attr('x2', 10)
      .attr('y2', 0)
      .attr('stroke', (d) => d.color)
      .attr('stroke-width', 2);

    linkLegend
      .append('text')
      .attr('x', 15)
      .attr('y', 5)
      .attr('fill', '#000')
      .text((d) => d.label);
  }
}
