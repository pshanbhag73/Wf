import { Component, AfterViewInit, Input, ViewChild, ElementRef } from '@angular/core';
import * as d3 from 'd3';

@Component({
  selector: 'app-dependency-graph',
  template: `
    <div class="container">
      <svg #graphSvg></svg>
    </div>
  `,
  styles: [`
    .container {
      width: 100%;
      height: 100%;
    }
    .link {
      stroke-width: 1.5px;
    }
    .node circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .node text {
      font-size: 12px;
      fill: #333;
    }
  `]
})
export class DependencyGraphComponent implements AfterViewInit {
  @Input() nodes: any[] = [];
  @Input() links: any[] = [];
  @ViewChild('graphSvg', { static: false }) graphSvg!: ElementRef<SVGSVGElement>;

  private width = 960;
  private height = 600;
  private simulation: any;
  private svg: any;
  private zoomLayer: any;
  private node: any;
  private link: any;

  constructor() {}

  ngAfterViewInit(): void {
    this.initializeGraph();
  }

  private initializeGraph(): void {
    this.svg = d3.select(this.graphSvg.nativeElement)
      .attr('width', this.width)
      .attr('height', this.height);

    this.zoomLayer = this.svg.append('g');

    this.simulation = d3.forceSimulation(this.nodes)
      .force('link', d3.forceLink(this.links).id((d: any) => d.id).distance(100))
      .force('charge', d3.forceManyBody().strength(-100))
      .force('center', d3.forceCenter(this.width / 2, this.height / 2))
      .on('tick', this.ticked.bind(this));

    this.link = this.zoomLayer.selectAll('.link')
      .data(this.links)
      .enter()
      .append('line')
      .attr('class', 'link')
      .attr('stroke', '#999')
      .attr('stroke-opacity', '0.6');

    this.node = this.zoomLayer.selectAll('.node')
      .data(this.nodes)
      .enter()
      .append('g')
      .attr('class', 'node')
      .call(d3.drag()
        .on('start', this.dragStarted.bind(this))
        .on('drag', this.dragged.bind(this))
        .on('end', this.dragEnded.bind(this)));

    this.node.append('circle')
      .attr('r', 5)
      .attr('fill', '#69b3a2');

    this.node.append('text')
      .attr('dx', 12)
      .attr('dy', '.35em')
      .text((d: any) => d.id);

    this.svg.call(d3.zoom()
      .extent([[0, 0], [this.width, this.height]])
      .scaleExtent([0.1, 8])
      .on('zoom', (event: any) => {
        this.zoomLayer.attr('transform', event.transform);
      }));
  }

  private ticked(): void {
    this.link
      .attr('x1', (d: any) => d.source.x)
      .attr('y1', (d: any) => d.source.y)
      .attr('x2', (d: any) => d.target.x)
      .attr('y2', (d: any) => d.target.y);

    this.node
      .attr('transform', (d: any) => `translate(${d.x},${d.y})`);
  }

  private dragStarted(event: any, d: any): void {
    if (!event.active) this.simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  private dragged(event: any, d: any): void {
    d.fx = event.x;
    d.fy = event.y;
  }

  private dragEnded(event: any, d: any): void {
    if (!event.active) this.simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  // Watch for changes in inputs (equivalent to Vue's watch)
  ngOnChanges(): void {
    if (this.svg) {
      this.svg.selectAll('*').remove(); // Clear existing graph
      this.initializeGraph();
    }
  }
}
