Angular Coding Standards and Best Practices
Follow the official Angular Style Guide (angular.dev/style-guide) for consistency and maintainability. Key points to reduce common PR issues like unused code/variables:
Naming Conventions:
Files: kebab-case (e.g., user-list.component.ts).
Components: UpperCamelCase selector (e.g., app-user-list).
Classes: UpperCamelCase.
Variables/Methods: lowerCamelCase.
Constants: UPPER_SNAKE_CASE.
Component Structure:
Keep files small (aim < 400 lines).
Order in class: Inputs/Outputs first, then properties, then methods.
Use standalone components where possible (modern default).
Refactor complex logic out of templates into TypeScript.
Clean Code Practices:
Remove unused imports, variables, and declarations immediately — this is one of the most common review comments.
No commented-out code.
Avoid duplication (DRY principle).
Use meaningful names; no abbreviations unless standard (e.g., config instead of cfg).
Linting and Tools to Prevent Issues:
Use ESLint (migrated from TSLint) with @angular-eslint plugin.
Enable rules like @typescript-eslint/no-unused-vars and no-unused-vars.
In tsconfig.json, set "noUnusedLocals": true and "noUnusedParameters": true to catch unused variables/parameters at compile time.
For standalone components, Angular (v19+) detects unused items in imports array — run ng run your-project:cleanup-unused-imports to auto-remove.
In VS Code: Use "Organize Imports" (Shift+Alt+O) or quick fix to remove unused imports.
Run ng lint before committing/PR.
Other Best Practices:
Prefer signals for state management in new code.
Use Prettier for auto-formatting.
Inline templates for simple components; external for complex.
Java Spring Boot API Coding Standards and Best Practices
Follow clean code principles and Spring Boot conventions for readable, maintainable APIs.
Project Structure (Layered/Package-by-Feature):
com.example.myapp
├── MyAppApplication.java (main class with @SpringBootApplication)
├── config/          (configurations)
├── controller/      (@RestController classes)
├── service/         (business logic)
├── repository/      (Spring Data JPA interfaces)
├── entity/          (JPA entities)
├── dto/             (Data Transfer Objects)
├── exception/       (custom exceptions/handlers)
└── util/            (helpers)
Avoid default package.
Naming Conventions:
Classes: UpperCamelCase (e.g., UserController).
Methods/Variables: lowerCamelCase.
Packages: lowercase reversed domain (e.g., com.example.myapp.controller).
REST endpoints: Noun-based, kebab-case (e.g., /users/{id}).
REST API Standards:
Use correct HTTP methods: GET (read), POST (create), PUT (full update), PATCH (partial update), DELETE.
Return proper status codes (e.g., 200 OK, 201 Created, 204 No Content, 400 Bad Request, 404 Not Found).
Use DTOs for requests/responses; avoid exposing entities directly.
For PATCH: Use @PatchMapping and handle partial updates carefully (e.g., with BeanUtils or MapStruct).
Clean Code Practices:
Remove unused code, variables, imports, and dependencies — common review blocker.
No dead/commented-out code.
Keep methods short (< 20-30 lines); single responsibility.
Avoid duplication; extract helpers/services.
Use Lombok sparingly (@Data, @Getter/@Setter) to reduce boilerplate, but not overuse.
Linting and Tools:
Use Checkstyle, SpotBugs, or SonarLint for static analysis.
IDEs (IntelliJ/Eclipse) highlight unused code — remove before PR.
Maven/Gradle plugin: dependency:analyze to detect unused dependencies.
Enable compiler warnings; use @SuppressWarnings sparingly.
Other Best Practices:
Use Spring Data JPA for repositories.
Proper exception handling (@ControllerAdvice).
Logging: Use SLF4J/Logback; no System.out.
Configuration: @ConfigurationProperties for external props.
Testing: Write unit (Mockito) and integration (@SpringBootTest) tests.
General Tips to Reduce PR Review Fatigue
Run linters/formatters locally before committing (e.g., ng lint, mvn checkstyle:check).
Use Git hooks (Husky for Angular, pre-commit for Java) to enforce checks.
Ignore AI suggestions (Copilot/GitHub Copilot) blindly — always review for unused code.
Self-review PRs: Search for // TODO, commented code, unused vars.
Share this as a team guideline document (e.g., in repo README or Confluence) so everyone follows the same standards. This will drastically cut down on repetitive review comments!
