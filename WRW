import java.time.Instant;
import java.time.Duration;
import java.util.List;

public class SmartActivityDetector {

    public record ActivityResult(
            boolean active,
            String reason,
            double currentLoad,
            double baselineLoad,
            Instant evaluatedAt
    ) {}

    private final DataQueryService queryService;

    // Tunable thresholds (adjust per environment)
    private static final double ABSOLUTE_ACTIVE_THRESHOLD = 15.0;   // 15% combined CPU+Mem above baseline → active
    private static final double IDLE_THRESHOLD = 10.0;             // < 10% combined → definitely idle
    private static final long RECENT_WINDOW_MINUTES = 12;          // Look at last 12 min
    private static final long BASELINE_WINDOW_MINUTES = 90;        // Baseline from 90–102 min ago (avoids recent spikes)

    public SmartActivityDetector(DataQueryService queryService) {
        this.queryService = queryService;
    }

    public ActivityResult detectCurrentActivity(String deviceId) {
        Instant now = Instant.now();
        Instant recentStart = now.minus(Duration.ofMinutes(RECENT_WINDOW_MINUTES));

        // 1. Get recent metrics (last ~12 min)
        List<MetricRecord> recent = queryService.queryDeviceMetrics(
                deviceId, recentStart, now);

        if (recent.isEmpty()) {
            return new ActivityResult(false, "No recent metrics", 0, 0, now);
        }

        // 2. Compute current combined load (avg CPU + avg Mem)/2
        double avgCpu = recent.stream().mapToDouble(MetricRecord::cpuUsagePercent).average().orElse(0.0);
        double avgMem = recent.stream().mapToDouble(MetricRecord::memoryUsagePercent).average().orElse(0.0);
        double currentLoad = (avgCpu + avgMem) / 2.0;

        // 3. Compute true idle baseline (90–102 min ago → avoids contamination from recent activity)
        Instant baselineStart = now.minus(Duration.ofMinutes(BASELINE_WINDOW_MINUTES + RECENT_WINDOW_MINUTES));
        Instant baselineEnd   = now.minus(Duration.ofMinutes(BASELINE_WINDOW_MINUTES));

        List<MetricRecord> baselineMetrics = queryService.queryDeviceMetrics(deviceId, baselineStart, baselineEnd);

        double baselineLoad = 5.0; // safe default for brand-new devices
        if (!baselineMetrics.isEmpty()) {
            double bCpu = baselineMetrics.stream().mapToDouble(MetricRecord::cpuUsagePercent).average().orElse(5.0);
            double bMem = baselineMetrics.stream().mapToDouble(MetricRecord::memoryUsagePercent).average().orElse(5.0);
            baselineLoad = (bCpu + bMem) / 2.0;
        }

        // 4. Decision logic — uptrend NOT required
        boolean active;
        String reason;

        if (currentLoad >= baselineLoad + ABSOLUTE_ACTIVE_THRESHOLD) {
            active = true;
            reason = String.format("High load (%.1f%% vs baseline %.1f%%)", currentLoad, baselineLoad);
        }
        else if (currentLoad <= IDLE_THRESHOLD) {
            active = false;
            reason = String.format("Idle level (%.1f%% ≤ %.0f%%)", currentLoad, IDLE_THRESHOLD);
        }
        else {
            // In the "gray zone": not clearly idle, not clearly spiked
            // → treat as active (better to over-report than under-report running services)
            active = true;
            reason = String.format("Moderate sustained load (%.1f%% > idle)", currentLoad);
        }

        return new ActivityResult(active, reason, round(currentLoad), round(baselineLoad), now);
    }

    private double round(double val) {
        return Math.round(val * 10.0) / 10.0;
    }





Goal: Detect if a device/service is currently active, regardless of whether usage is going up, down, or stable — as long as it's meaningfully above idle.
New Rules (more accurate):
Compute baseline from the last 1–2 hours (idle/reference period).
Compute current average from the last 10–15 minutes.
If current average ≥ baseline + absolute_threshold → ACTIVE
(absolute_threshold = e.g. 15% combined CPU+Mem)
Optional softener: even if slightly below, if recent max was high → still active (handles cooldown)
Only mark inactive if current load is very close to historical idle (e.g. < 8–10%)



// Conservative (fewer false positives)
ABSOLUTE_ACTIVE_THRESHOLD = 20.0
IDLE_THRESHOLD = 8.0

// Aggressive (never miss a running service)
ABSOLUTE_ACTIVE_THRESHOLD = 12.0
IDLE_THRESHOLD = 12.0



