Algorithm: Detect Application Activity from Metrics Trends
This algorithm determines if an application (or service instance) is "active" at a given query time T by analyzing CPU/memory trends from the device_metrics collection. It compares the recent trend (last 15 minutes) against a historical baseline (last 1 hour) to detect spikes indicative of activity, reducing false positives from idle baselines.
Inputs:
Query time T (ISODate).
Device ID or app instance ID (to filter metrics).
Thresholds: activity_threshold (e.g., 20% above baseline), window_recent (e.g., 15 minutes), window_historical (e.g., 60 minutes).
Min samples: At least 3 data points per window.
Pseudocode (Python-like for clarity):
function is_active(T, device_id, activity_threshold=20, window_recent=15, window_historical=60):
    # Step 1: Fetch recent metrics (T - window_recent to T)
    recent_metrics = query_device_metrics(device_id, T - window_recent mins, T)
    if len(recent_metrics) < 3:
        return False  # Insufficient data
    
    # Step 2: Compute recent trend (simple linear regression slope for CPU + memory avg)
    recent_cpu_avg = average([m.cpu_usage_percent for m in recent_metrics])
    recent_mem_avg = average([m.memory_usage_percent for m in recent_metrics])
    recent_combined = (recent_cpu_avg + recent_mem_avg) / 2  # Normalize to 0-100
    
    # Step 3: Fetch historical baseline (T - window_historical to T - window_recent)
    historical_metrics = query_device_metrics(device_id, T - window_historical mins, T - window_recent mins)
    if len(historical_metrics) < 3:
        baseline = 5  # Fallback low baseline for idle
    else:
        historical_cpu_avg = average([m.cpu_usage_percent for m in historical_metrics])
        historical_mem_avg = average([m.memory_usage_percent for m in historical_metrics])
        baseline = (historical_cpu_avg + historical_mem_avg) / 2
    
    # Step 4: Detect activity via trend comparison
    trend_delta = recent_combined - baseline
    if trend_delta > activity_threshold:
        # Optional: Confirm with slope (positive trend in recent window)
        recent_slope = linear_regression_slope([m.timestamp for m in recent_metrics], 
                                              [m.cpu_usage_percent for m in recent_metrics])  # Or use combined
        if recent_slope > 0:  # Rising trend
            return True, f"Active: {trend_delta:.1f}% above baseline"
    
    return False, f"Inactive: {trend_delta:.1f}% delta from baseline"
Explanation of Steps:
Fetch Recent Data: Query the last window_recent minutes to capture current state.
Compute Recent Trend: Average CPU/memory for a snapshot; use slope for directionality if needed (e.g., via NumPy's polyfit for regression).
Compute Baseline: Average from the prior window_historical to establish "normal" idle/load.
Compare & Decide: If recent avg exceeds baseline by threshold and shows a positive trend, mark as active. This handles varying workloads (e.g., bursty apps).
Edge Cases Handled:
Low data: Fall back to inactive or low baseline.
No trend: Relies on absolute delta.
Integrate with service collection: Cross-check DC match and APM status for confirmation.
This setup allows querying at time T: Join collections on DC/timestamp, apply the algorithm to metrics, and overlay APM data for a full view. If implementing in code, use libraries like Pandas for averages/slopes
